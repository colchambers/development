<!DOCTYPE html>

<html>

<head>
    <title>Net</title>
	
	<style type="text/css">

		body {
			background: #000;
			color: #EEE;
			padding: 0;
			margin: 0;
			font-weight: bold;
			overflow: hidden;

			font-family: Monospace;
			font-size: 13px;
			text-align: center;
		}

		#info {
			position: absolute;
			top: 0px;
			width: 100%;
			padding: 5px;
			z-index: 100;
		}

		a { color: green; }
		b { color: green; }
		
		#gui-container {
			position: absolute;
			top: 0;
			right: 0;
			z-index: 100;
		}
		
		.guidat {
			float: none;
			margin-bottom: 0;
		}

	</style>
	
	<script type="text/javascript" src="../../lib/jquery/1.6.2.js"></script>
	<script type="text/javascript" src="../../lib/3d/Three.js"></script>
	<script type="text/javascript" src="../../lib/Tween.js"></script>
	<script type="text/javascript" src="../../lib/DAT.GUI.js"></script>
	<script type="text/javascript" src="js/Detector.js"></script>
	<script type="text/javascript" src="js/RequestAnimationFrame.js"></script>
	<script type="text/javascript" src="js/Stats.js"></script>
    <body>
		<div id="info">
			<a href="http://github.com/mrdoob/three.js" target="_blank">three.js</a> - earth [trackball camera]<br/><br/>
			<b>MOVE</b> mouse & press <b>LEFT/A:</b> rotate, <b>MIDDLE/S:</b> zoom, <b>RIGHT/D:</b> pan
		</div>
		
		<video id="video" autoplay loop style="display:none"  controls >
			<source src="textures/4.step_out.mp4" type='video/mp4; codecs="avc1.42E01E, mp4a.40.2"'>
			<source src="textures/sintel.ogv" type='video/ogg; codecs="theora, vorbis"'>
		</video>
		<div id="gui-container"></div>
		
    <script type="text/javascript">
	var height = window.innerHeight,
	width  = window.innerWidth,

	container, stats,

	camera, scene, renderer,
	geometry, 
	light, ambientLight, ball, net, grid,
	courtMesh, court_tile,

	time = new Date().getTime();
	var objects = {};
	objects.lights = {};
	objects.video = null;
	objects.meshes = {};
	objects.rallies = [];
	var video, texture, material, videoMesh;
		;
	
/*
 * Tennis court dimensions
 * Doubles
 * Length:78'
 * width:36'
 *
 * Singles width: 27'
 * service length: 21'
 * 
 */
 
 // dimension variables
 var court = {};
 court.scale = 10;
 court.length = 76;
 court.width = 38;
 court.serviceLength = 21;
 court.singlesWidth = 27;
 court.fenceHeight = 12;
 court.overallLength = 120;
 court.overallWidth = 60;
 court.overallStadiumLength = 130;
 court.overallStadiumWidth = 70;
 court.area = {};
 court.area.topPadding = 5;
 court.area.sidePadding = 5;
 court.area.length = (court.length + court.area.topPadding + 10);
 court.area.width = (court.width + court.area.sidePadding + 10);
 court.net = {}
 court.net.singlesWidth = 36;
 court.net.doublesWidth = 40;
 court.net.height = 3.5;
 
 function getByScale(dimension){
     return dimension * court.scale;
 }

	window.onload = function() {

		if ( !Detector.webgl ) {

			Detector.addGetWebGLMessage();
			return;

		}

		init();
		init_datgui();
		animate();

	}
	
    function init() {

		container = document.createElement( 'div' );
		document.body.appendChild( container );
		scene = new THREE.Scene();

		renderer = new THREE.WebGLRenderer( { clearAlpha: 1, clearColor: 0xFFFFFF } );
		renderer.setSize( width, height );
		renderer.sortObjects = false;
		renderer.autoClear = false;
		container.appendChild( renderer.domElement );

		initCamera();
		//var material = new THREE.MeshLambertMaterial( { color: 0xffffff, wireframe: true } );

		//camera.target = ball;
		
		initBall();
		createBallAnimation();
		createNet();
		createCourt();
		//createGrid();
		initVideo();
		renderer.autoClear = false;

		
		initLights();

		//renderer.render(scene, camera);

		stats = new Stats();
		stats.domElement.style.position = 'absolute';
		stats.domElement.style.top = '0px';
		stats.domElement.style.zIndex = 100;
		container.appendChild( stats.domElement );

		window.addEventListener( 'resize', onWindowResize, false );

	};
	
	function createAndAddLight(options) {
		light = options.t =='point'?new THREE.PointLight( options.c ): new THREE.DirectionalLight( options.c );
		light.position.set( options.x, options.y, options.z );
		if(options.t == 'directional') {
			light.position.normalize();
		}
		scene.addLight( light );
		return light;
	}
	function initLights() {
		
		objects.lights.pointLight = createAndAddLight({t: 'point', c: 0xffffff,
				x: 10, y: 100, z: 10});
				
		objects.lights.directionLight = createAndAddLight({t: 'directional', c: 0xffffff,
				x: 900, y: 1500, z: 1});
	}
	
	function initBall() {
		
		ball = new THREE.Mesh(
			new THREE.SphereGeometry( 5, 5, 5 ),
			new THREE.MeshLambertMaterial( { color: 0xFFFF00 } )
		);
		
		ball.position.x = 10;
		ball.position.y = 40;
		ball.position.z = getByScale(court.length/2);
		scene.addObject( ball );
	}
	
	function createTween(index) {
		var options = objects.rallies[index];
		
		var tween = new TWEEN.Tween(options.p).to(options.t, 2000);
		tween.onUpdate(function(){
			ball.position.x = options.p.x;
			ball.position.y = options.p.y;
			ball.position.z = options.p.z;
		});
		return tween;
	}
	function createBallAnimation() {
		rallies = objects.rallies;
		var singlesWidth = getByScale(court.singlesWidth);
		var court_length = getByScale(court.length);
		var court_width = getByScale(court.width);
		
		// toss
		var rally_count = 0;
		rallies[rally_count] = {
			p: { x : ball.position.x, y: ball.position.y, z: ball.position.z },
			t: { x : ball.position.x, y: 250, z: ball.position.z }
		};
	
		// serve
		rally_count++;
		rallies[rally_count] = {
			t: { x : -getByScale((court.singlesWidth*0.8)/2), y: 0, z: -getByScale((court.serviceLength*0.8)/2) }
		};
		
		// serve after bounce
		rally_count++;
		rallies[rally_count] = {
			t: { x : -((rallies[0].t.x-rallies[rally_count-1].t.x)*2), y: 40, z: -((rallies[0].t.z+rallies[rally_count-1].t.z)*2) }
		};

		// return
		rally_count++;
		rallies[rally_count] = {t: { x : 0, y: 80, z: 10 }};
		
		// volley
		rally_count++;
		rallies[rally_count] = {t: { x : ((singlesWidth*0.7)/2), y: 0, z: -((court_length*0.8)/2) }};
		
		// volley after bounce
		rally_count++;
		rallies[rally_count] = {t: { x : ((singlesWidth*1.4)/2), y: 0, z: -((court_length*1.6)/2) }};
		
		// Add positions from previous target
		for(var x=0; x<rallies.length;x++) {
			if(rallies[x].p) {
				continue;
			}
			rallies[x].p = rallies[x-1].t;
		}
		
		// chain tweens
		var tweens = [];
		for(var x=0; x<rallies.length;x++) {
			tweens.push(createTween(x));
			if(!x){
				continue;
			}
			tweens[x-1].chain(tweens[x]);
		}
		// play
		tweens[0].start();
	}
	
	function initCamera() {
		camera = new THREE.TrackballCamera({

			fov: 35,     // Field of view
			aspect: width / height,  // Aspect ratio
			near: .1,     // Near
			far: 10000,       // Far

			rotateSpeed: 1.0,
			zoomSpeed: 1.2,
			panSpeed: 0.2,

			noZoom: false,
			noPan: false,

			staticMoving: false,
			dynamicDampingFactor: 0.3,

			
			keys: [ 65, 83, 68 ], // [ rotateKey, zoomKey, panKey ],

			domElement: renderer.domElement,

		});
		camera.position.set( 15, 250, 840 );
	}
	
	function initVideo() {
		var overallStadiumLength = getByScale(court.overallStadiumLength);
		
		video = document.getElementById( 'video' );
		objects.video = video;

		//video.volume = 0;
		video.muted = true;

		texture = new THREE.Texture( video );
		texture.minFilter = THREE.LinearFilter;
		texture.magFilter = THREE.LinearFilter;

		var geometry;

		video_x = 1;
		video_y = getByScale(court.width)*0.6;
		video_z = getByScale(court.width);

		var parameters = { color: 0xffffff, map: texture },
		geometry = new THREE.CubeGeometry( video_x, video_y, video_z );
		material = new THREE.MeshLambertMaterial( parameters );
		videoMesh = new THREE.Mesh( geometry, material );
		objects.meshes.video = videoMesh;
		
		videoMesh.position.x = 0;
		videoMesh.position.y = video_y/2; //100
		videoMesh.position.z = (-overallStadiumLength/2)+30; // -600
		
		videoMesh.rotation.y = 1.5;

		scene.addObject(videoMesh);
	}
		
	function createAndAddFence(options) {
		var fence = new THREE.Mesh(
			new THREE.CubeGeometry( options.w, options.h, options.d ),
			new THREE.MeshLambertMaterial( { color: 0x0000FF } )
		);
		fence.position.x=options.x;
		fence.position.y=options.y;
		fence.position.z=options.z;
		scene.addObject( fence );
		return fence;
	}
	function createCourt() {
		var length = getByScale(court.length)/2;
		var width = getByScale(court.width)/2;
		var singles_width = getByScale(court.singlesWidth)/2;
		var service_length = getByScale(court.serviceLength)/2;
		var centre = 0;
		var overallStadiumLength = getByScale(court.overallStadiumLength);
		var overallStadiumWidth = getByScale(court.overallStadiumWidth);
		var fenceHeight = getByScale(court.fenceHeight);
		
		// fences
		// blue top fence
		top_fence = createAndAddFence({w:overallStadiumWidth, h: fenceHeight, d: 0, 
						x:0, y: fenceHeight/2, z: (-overallStadiumLength/2)});
		//bottom_fence = createAndAddFence({w:overallStadiumWidth, h: fenceHeight, d: 0, 
		//				x:0, y: fenceHeight/2, z: (overallStadiumLength/2)});
		left_fence = createAndAddFence({w:0, h: fenceHeight, d: overallStadiumLength, 
						x:(-overallStadiumWidth/2), y: fenceHeight/2, z: 0});
		right_fence = createAndAddFence({w:0, h: fenceHeight, d: overallStadiumLength, 
						x:(overallStadiumWidth/2), y: fenceHeight/2, z: 0});

		// Green courtside
		court_side_tile = new THREE.Mesh(
			new THREE.CubeGeometry( overallStadiumWidth, 0, overallStadiumLength ),
			new THREE.MeshLambertMaterial( { color: 0x00FF00 } )
		);
		court_side_tile.position.y=-2;
		scene.addObject( court_side_tile );
		
		// blue court
		court_tile = new THREE.Mesh(
			new THREE.CubeGeometry( width*2, 0, length*2 ),
			new THREE.MeshLambertMaterial( { color: 0x0000FF } )
		);
		court_tile.position.y=-1;
		scene.addObject( court_tile );
		
		// Court lines
		var line_material = new THREE.LineBasicMaterial( { color: 0xFFFFFF, opacity: 1, linewidth: 50 } ),
			geometry = new THREE.Geometry(),
			floor = 0;
		
		dimensions = [
				// Court boundary
				// left
				{x:-width, y:length, z: 0},
				{x:-width, y:-length, z: 10},
				// right
				{x:width, y:length},
				{x:width, y:-length},
				// near
				{x:width, y:length},
				{x:-width, y:length},
				// far
				{x:width, y:-length},
				{x:-width, y:-length},
				// tramlines
				// left
				{x:-singles_width, y:-length},
				{x:-singles_width, y:length},
				// right
				{x:singles_width, y:-length},
				{x:singles_width, y:length},
				// service boxes
				// near
				{x:singles_width, y:service_length},
				{x:-singles_width, y:service_length},
				// far
				{x:singles_width, y:-service_length},
				{x:-singles_width, y:-service_length},
				// centre
				{x:centre, y:service_length},
				{x:centre, y:-service_length}
			];
		length = dimensions.length;
		for(var x=0; x<length; x++){
			geometry.vertices.push( new THREE.Vertex( new THREE.Vector3( dimensions[x].x, floor, dimensions[x].y ) ) );
		}
		
		courtMesh = new THREE.Line( geometry, line_material, THREE.LinePieces );
		scene.addObject( courtMesh );
	}
	
	function createGrid() {
		//Court grid

		var line_material = new THREE.LineBasicMaterial( { color: 0x000000, opacity: 0.2 } ),
			geometry = new THREE.Geometry(),
			floor = -75, step = 25;

		for ( var i = 0; i <= 40; i ++ ) {
			geometry.vertices.push( new THREE.Vertex( new THREE.Vector3( - 500, floor, i * step - 500 ) ) );
			geometry.vertices.push( new THREE.Vertex( new THREE.Vector3(   500, floor, i * step - 500 ) ) );
			geometry.vertices.push( new THREE.Vertex( new THREE.Vector3( i * step - 500, floor, -500 ) ) );
			geometry.vertices.push( new THREE.Vertex( new THREE.Vector3( i * step - 500, floor,  500 ) ) );
		}

		grid = new THREE.Line( geometry, line_material, THREE.LinePieces );
		scene.addObject( grid );
	}
	
	function createNet(){
		var sx=getByScale(court.net.singlesWidth), sy=getByScale(court.net.height), sz=1, p = new THREE.Vector3(0, sy/2, 0)
		net = new THREE.Mesh(
				new THREE.CubeGeometry( sx, sy, sz ), 
				new THREE.MeshLambertMaterial( { color: 0x003300, wireframe: true  } ) 
			);
		net.updateMatrix();

		net.position = p;
		scene.addObject(net);
	}
	
	function createAndAddDatGui(options) {
		var gui = new DAT.GUI();
		var e = options.e;
		var positions = ['x', 'y', 'z'];
		var length = positions.length;
		
		gui.name(options.n);
		
		for(var x=0;x<length;x++){
			gui.add(e.rotation, positions[x], 0, 5, 0.1).name('rotation.'+positions[x]);
		}
		for(var x=0;x<length;x++){
			gui.add(e.position, positions[x],  -1500, 1500, 100).name('position.'+positions[x]);
		}
		
		document.getElementById('gui-container').appendChild(gui.domElement);
		gui.close();
		return gui;
	}
	
	function init_datgui() {
		var court_gui = new DAT.GUI();
		
		court_gui.name('Court');
		// Text field
		positions = ['x', 'y', 'z'];
		length = positions.length;
		for(var x=0;x<length;x++){
			court_gui.add(ball.position, positions[x], 0, 2000, 20).name('ball.position.'+positions[x]);
		}
	   
	    for(var x=0;x<length;x++){
			court_gui.add(camera.position, positions[x], 0, 2000, 20).name('camera.position.'+positions[x]);
		}
		
		for(var x=0;x<length;x++){
			court_gui.add(net.scale, positions[x], 1, 10).name('net.scale.'+positions[x]);
		}

		// Add guis to container
		document.getElementById('gui-container').appendChild(court_gui.domElement);
		
		// close guis
		court_gui.close();
		
		var video_gui = createAndAddDatGui({e: objects.meshes.video, n: 'Video'});
		video_gui.add(video, 'muted');
		video_gui.add(video, 'volume', 0, 1, 0.1);
		
		// light
		var light_gui = createAndAddDatGui({e: objects.lights.directionLight, n: 'Light'});
		var point_light_gui = createAndAddDatGui({e: objects.lights.pointLight, n: 'Point Light'});
		
	}


	function onWindowResize( event ) {

		width = window.innerWidth;
		height = window.innerHeight;

		renderer.setSize( width, height );

		camera.aspect = width / height;
		camera.updateProjectionMatrix();

		camera.screen.width = width;
		camera.screen.height = height;

		camera.radius = ( width + height ) / 4;

	};

	
	
	function animate() {

		requestAnimationFrame( animate );

		render();
		stats.update();
		TWEEN.update();
	};

	function render() {
		
		
		if ( video.readyState === video.HAVE_ENOUGH_DATA ) {
			if ( texture ) texture.needsUpdate = true;
		}
				
		renderer.clear();
		renderer.render( scene, camera );

	};
    </script>
</head>
</body>

</html>